
# Stack
 - if you need keep track of previous element.
 - looking got next greater or smaller element.
 - if you need keep track of minimum or maximum element.

# Hashmap
 - if you need to keep track of frequency of elements.
 - if you need to check if an element exists or not in O(1) time.
 - if you need to group elements based on some property.


 # Priority Queue
 - if you need to keep track of largest or smallest elements.
 - you need top K elements.
 - need to pull smallest or largest element at any point of time. ( where insertion and deletion happens frequently
 c)

# Approach To Solve
- Given a problem here are some questions that should help you figure out the general direction of how to solve it

1. Which data structure can I use? Arrays, LinkedList, HashMap, Heap, Tree, or Trie
2. Do I need to use 2 data structures? eg: LRU
3. How do I break the problem into smaller units, is there a problem within a problem, can i write a decision tree?
4. Does this problem look similar to other problems you have solved?
5. Will sorting make the problem easier to solve?
6. Can I use any algorithmic techniques, like bfs, dfs, two pointer etc.
7. Do any design patterns apply that could make it easier to maintain, like observer pattern?
8. What is the time & space complexity? Best case, worst case time complexity? Average case is usually difficult to derive.


# Coding patterns

1. Pattern: Two Pointers
-  This method uses two pointers to traverse an array or a list from `different ends or directions`.

3. Pattern: Fast & Slow Pointers
- two pointers move at` different speeds` in a data structure

4. Pattern: Sliding Window
- creating a ‘window’ into the data structure and then moving that window around to gather specific information.

5. Pattern: Merge Intervals

1. Prefix Sum

# Algorithm
## Binary Search Algorithm



## two pointer approach

## merge interval


## Sliding window 
 